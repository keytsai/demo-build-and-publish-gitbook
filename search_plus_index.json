{"./":{"url":"./","title":"簡介","keywords":"","body":"簡介簡介 這裡記錄學習筆記 "},"articles/back-end/java/":{"url":"articles/back-end/java/","title":"Java","keywords":"","body":"Java特色Java 特色 跨平台 簡單 物件導向 安全 穩定的 非常重視型別(strong-type) 使用列舉型別(enum)、泛型(generic)等功能在程式編譯時即檢查出型態問題 提供記憶體回收功能，較不會有OutOfMemory狀況發生 多執行緒 "},"articles/back-end/java/jdbc.html":{"url":"articles/back-end/java/jdbc.html","title":"JDBC","keywords":"","body":"JDBC隔離等級JDBC 隔離等級 "},"articles/back-end/java/javabase/":{"url":"articles/back-end/java/javabase/","title":"基礎Java","keywords":"","body":"基礎Java基礎Java "},"articles/back-end/java/javabase/variable.html":{"url":"articles/back-end/java/javabase/variable.html","title":"Variable","keywords":"","body":"Variable變數型別基本型別變數的有效範圍實例變數(Instance variable)，亦即類別屬性或欄位區域變數(Local variable)型別的升等與轉型Variable 變數型別 Java的型別分為兩大類： 基本型別(Primitive Type) 參考型別(Reference Type) 基本型別 基本型別共八種： 類型 型別 位元組 位元數 最小值 最大值 整數 byte 1 8 -128 127 整數 short 2 16 整數 int 4 32 整數 long 8 64 浮點數 float 32-bit 浮點數 double 64-bit 字元 char 2 16 布林值 boolean 1 8 變數的有效範圍 實例變數(Instance variable)，亦即類別屬性或欄位 有效範圍在整個實例(instance)內 使用前若未給值(未初始化)，將依其型別給予預設值： 型別分類 基本型別 預設值 整數 byte、short、int、long 0 浮點數 float、double 0.0 字元 char 空字元，為'' or '\\u0000' 邏輯 boolean false 區域變數(Local variable) 有效範圍在宣告的方法或特定程式碼{}內。若變數名稱和外圍變數名稱相同，區域變數會覆蓋實例變數 宣告的型態前面不能再加public等修飾詞 使用前若未給值(初始化)，將會編譯失敗 型別的升等與轉型 升等：小型別會自動提升為與大型別一致 轉型：通常用於將大型別轉成小型別 語法：(target_type)value "},"articles/back-end/java/javabase/referencetype.html":{"url":"articles/back-end/java/javabase/referencetype.html","title":"參考型別","keywords":"","body":"參考型別使用物件參考有如遙控器的概念由類別(class)建構物件對不同物件使用不同物件參考JVM記憶體分類使用String類別String類別的其他方法StringBuilder基本型別的包覆類別參考型別 使用物件參考 利用類別(class)建立並使用物件(object) 有如遙控器的概念 要使用「物件」，必須使用該物件的「物件參考變數」(簡稱「物件參考」或「參考變數」) 概念上有如「電子產品」由「遙控器」遠端操控 名稱 概念 舉例 物件參考變數 遙控器 myPen 物件 電子產品 Pen 由類別(class)建構物件 建構物件有三個程序： 宣告(Declaration) 語法：ClassName reference(物件參考變數); 實體化(Instantiation) 語法：new ClassName; 將實體指定給物件參考，完成初始化(Initialization) 語法：reference = new ClassName // 1. 宣告 Book myBook; // Pen為類別名稱 // myPen為物件參考變數 // 2. 實體化 new Book(); // pen為類別名稱，將使用該類別產生物件實體 // 3. 初始化 myBook = new Book(); // 因無法直接碰觸記憶體裡的Pen物件，故使用物件參考myPen來控制 // 完整程序： Book myBook = new Book(); 比較基本型別和參考型別的變數宣告： 項目 型別 變數 指派運算子 記憶體內容 基本型別範例 int x = 10 參考型別範例 Book myBook = new Book() 對不同物件使用不同物件參考 不同種類物件，即使同種但不同的物件，都該使用各自的物件參考(遙控器)來對物件進行控制： Book myBook1 = new Book; myBook1.publishing(); Book myBook2 = new Book; myBook2.publishing(); Pen myPen = new Pen(); myPen.write(); 目前以上例來說，「宣告型別(reference type)」與所參照的「物件型態(object type)」都相同，兩者均為Book，實際上並不需要相同。以遙控器的比喻來說，目前一種遙控器只能控制一種裝置，但實務上有通用遙控器，經過一些設定後就能控制同種但不同品牌的電子產品，即為「多型」的概念。 JVM記憶體分類 Java記憶體分三大區塊： Global(全域) 保存static的類別成員變數的地方 Stack(堆疊) 保存基本型別(primitive type)的變數和變數內容(value)的地方 保存參考型別(reference type)的變數的地方 Heap(堆積) 保存參考型別(reference type)的變數內容(instance)的地方 Stack和Heap歸納如下： 分類 變數&變數值 Stack Heap 基本型別 變數 O 基本型別 值 O 參考型別 變數(物件參考\b) O 參考型別 值(物件實體) O 使用String類別 String類別屬於參考型別，使用時會產生物件 String物件可以不使用new關鍵字進行實體化，好處是透過字串池避免記憶體浪費 String類別的其他方法 方法 功能 length() 取得字串長度 toUpperCase() / toLowerCase() 將字串內的字元全部轉換為大寫或小寫 trim() 去除字串前後空白 substring() 由字串內取出全部字串 endsWith() 判斷字串結尾 StringBuilder 基本型別的包覆類別 基本型別 包覆類別 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 參考型別的包覆類別 "},"articles/back-end/java/javabase/array.html":{"url":"articles/back-end/java/javabase/array.html","title":"Array","keywords":"","body":"Array一維陣列與二維陣列陣列的基本定義建立一維陣列ArrayList類別陣列的缺點ArrayList類別簡介Array 一維陣列與二維陣列 陣列的基本定義 為一種容器物件(container object)，可裝載多個且單一型態的基本型別或參考型別 陣列裡的內容物稱為成員(element) 建立時必須指定長度，即成員數量；建立後長度即不能改變 陣列的成員使用數字化的索引(index)存取，第一個成員的index為0 建立一維陣列 陣列也是物件，因此建立陣列的完整程序也分下列三部分： 第一部分：宣告 type [] array_identifier; // type:陣列的成員型別 // []:表示宣告陣列 // array_identifier:陣列名稱 第二部分：建構實體 array_identifier = new type [length]; 第三部分：初始化 array_identifier[index] = value; // index:成員位置，從0開始，最大長度為「長度 - 1」 可將上述三個程序一次完成(前提為程式碼不能分行)： type [] array_identifier = {成員以\",\"區隔}; ArrayList類別 陣列的缺點 陣列無法自動增加長度，有諸多不便： 紀錄每個加入陣列的元素的索引 追蹤並記錄陣列長度 若長度不足，則必須建立一個足夠長度的新陣列，並將原陣列成員逐一複製過去，再捨棄原陣列 ArrayList類別簡介 只存放參考型別的物件，不接受基本型別；但可以改用基本型別的包覆類別 有許多方法可以管理成員物件：add()、get()、remove()、indexOf()等 建構ArrayList物件時不需要設定長度大小，當需要加入更多成員物件時，將自動成長 在建構ArrayList物件時可設定initial capacity，但不強制 "},"articles/back-end/java/javabase/Method.html":{"url":"articles/back-end/java/javabase/Method.html","title":"方法","keywords":"","body":"使用方法宣告static方法和變數沒有static時的困境使用static解決問題static宣告的意義static宣告的時機建立多載的方法方法的簽名方法的多載變數值的傳遞變數值傳遞的發生場景Pass by Value使用方法 宣告static方法和變數 若在屬性或方法前加上static修飾詞，則該屬性或方法使用時就不需要再透過物件生成 亦即直接使用類別，就能呼叫static方法和變數 沒有static時的困境 使用static解決問題 package course.c10; public class Circle1 { private double radius; static final double PI = 3.1415926; public void setRadius(double r) { this.radius = r; } // public double getArea() { return this.radius * this.radius * PI; } // 此為公式，結果只和輸入參數有關 static double areaFormula(double r) { return r * r * PI; } public static void main(String[] args) { System.out.println(Circle1.PI); // 圓半徑為1，求面積 System.out.println(Circle1.areaFormula(1)); // 圓半徑為10，求面積 System.out.println(Circle1.areaFormula(10)); } } static宣告的意義 每個類別只載入一次，故類別成員在JVM裡是唯一存在 物件成員可以呼叫類別成員 類別成員不能出叫物件成員 定義在類別內的所有屬性和方法分兩類： 未使用static宣告 必須先產生物件，再使用物件參考(遙控器)去呼叫 無static宣告的欄位和方法稱為物件成員(object member) 使用static宣告 因為只用類別名稱就可以呼叫方法和欄位，因此稱有static宣告的欄位和方法為類別成員(class member) static宣告的時機 public class Circle2 { private double radius; public void setRadius(double r) { this.radius = r; } public double getArea() { return areaFormula(this.radius); } // 此為公式，結果只和輸入參數有關 static double areaFormula(double r) { return r * r * Math.PI; } } 建立多載的方法 方法的簽名 方法名稱及參數合併稱為方法簽名(method signature) 就像用簽名識別身份，方法不只用方法名稱識別，還要加上參數 認定方法參數是否相同有三個考量： 數量 順序 型別 方法的多載 同一個類別內，若有方法名稱相同，但簽名不同(否則無法編譯)，就稱為多載(Overloading) 使用時機： 若類別內有多個方法功能相近，只是傳入的參數型態、數量不同，就可以使用多載進行coding 變數值的傳遞 變數值傳遞的發生場景 Java在兩種情況時需要傳遞(pass)變數/參數： 由指定運算子「=」右側，將值(value)傳遞給左側變數 透過方法宣告的參數，將值由呼叫者(caller)方法傳遞進入工作者(worker)方法中 Java使用「Pass by Value」來傳遞變數/參數 Pass by Value 參考型別 若變數屬於參考型別，則複製物件參考(遙控器)後進行傳遞。複製前後雖然是不同遙控器，但指向同一物件 基本型別 因為沒有遙控器的概念，因此是直接複製變數值，如同影印機複製原稿後產生副本，兩者各自獨立 "},"articles/back-end/java/javabase/collectionsapi.html":{"url":"articles/back-end/java/javabase/collectionsapi.html","title":"collections API","keywords":"","body":"collections APIcollections API "},"articles/back-end/java/servlet-web/":{"url":"articles/back-end/java/servlet-web/","title":"Servlet Web","keywords":"","body":"Servlet Web什麼是Servlet動手實作Servlet程序url位址如何與servlet程序連接Servlet Web 什麼是Servlet 是JavaEE規範之一，規範即介面 為JavaWeb三大組成之一(三大組成：Servlet程序、Filter過濾器、Listener監聽器) 是用Java編寫的伺服器端程式。其主要功能在於互動式地瀏覽和修改資料，生成動態Web內容 動手實作Servlet程序 編寫一個class去實作Servlet介面 實現service方法，處理請求，並回應數據 到web.xml中設定servlet程序的連接位址 常見錯誤1：url-pattern中設置的路徑沒有以/斜線開頭 常見錯誤2：servlet-name設置的值不存在 常見錯誤3：servlet-class名稱錯誤 package ken.servlet.test; import java.io.IOException; import javax.servlet.Servlet; import javax.servlet.ServletConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; public class HelloServlet implements Servlet { @Override public void destroy() { // TODO Auto-generated method stub } @Override public ServletConfig getServletConfig() { // TODO Auto-generated method stub return null; } @Override public String getServletInfo() { // TODO Auto-generated method stub return null; } @Override public void init(ServletConfig arg0) throws ServletException { // TODO Auto-generated method stub } @Override public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException { System.out.println(\"Hello Servlet 已連接\"); } } web.xml: ServletTest index.html index.htm index.jsp default.html default.htm default.jsp HelloServlet ken.servlet.test.HelloServlet HelloServlet /hello url位址如何與servlet程序連接 "},"articles/back-end/java/servlet-web/javabeans.html":{"url":"articles/back-end/java/servlet-web/javabeans.html","title":"JavaBeans","keywords":"","body":"JavaBeans三個特性JavaBeans 包裝資料，重複使用 三個特性 必須是一個public類別，且必須有一個不傳入參數的public建構子 取得或設定屬性(properties)時，必須用 getXxx 或 setXxx 的方法 必須是一個可序列化(Serializable)的類別，指 implements java.io.Serializable 空介面 "},"articles/back-end/java/servlet-web/request-parameters.html":{"url":"articles/back-end/java/servlet-web/request-parameters.html","title":"Request Parameters","keywords":"","body":"Request Parameters（請求參數）的傳遞方式GETPOSTRequest Parameters （請求參數）的傳遞方式 必考！ GET 於瀏覽器直接輸入URL時 點選超連結(hyperlink)時 HTML表單(form) POST HTML表單(form) "},"articles/back-end/java/servlet-web/servletlifecycle.html":{"url":"articles/back-end/java/servlet-web/servletlifecycle.html","title":"Servlet 生命週期","keywords":"","body":"Servlet 生命週期四個生命週期創建實體初始化服務卸載生命週期基本概念背景執行緒Servlet 生命週期 四個生命週期 創建實體 Servlet Reloading (Servlet 重載入) ->例外 Load on Startup (啟動時載入) ->例外 初始化 Init Parameter (初始參數) 服務 Persistence vs Synchronization Single Thread Model (單緒模型)(Deprecated) 卸載 Initial & Destroy (協同運作) 生命週期基本概念 Servlet container: 替我們建立servlet實體，並由其控制呼叫servlet的init(), service(), destroy()等方法，以管理servlet的生命週期 程式設計師：則藉由提供上述方法之實作，予以控制該servlet物件及與該物件相關之resource 背景執行緒 "},"articles/back-end/java/servlet-web/webxml.html":{"url":"articles/back-end/java/servlet-web/webxml.html","title":"web.xml部署檔","keywords":"","body":"web.xml部署檔web.xml部署檔 這個是應用程式部屬的描述檔，一定放在web.xml下，簡單來說，這個是用來起始程式的開始點. hi HelloWorld hi /hello.html hi /hello.html/* hi *.mm servlet開始，servlet結束 servlet-name servlet-class servlet-mapping開始，servlet-mapping結束 servlet-name url-pattern "},"articles/back-end/java/servlet-web/synchronization.html":{"url":"articles/back-end/java/servlet-web/synchronization.html","title":"同步化","keywords":"","body":"同步化同步化 第三種不可用 第一種效能最差，但都用這種，因為安全簡便 第三種效能最好 專案開發時，區域變數優先 "},"articles/back-end/java/servlet-web/reloading.html":{"url":"articles/back-end/java/servlet-web/reloading.html","title":"Servlet重載入","keywords":"","body":"Servlet重載入Servlet重載入 有一支重載入，大家都重載入 會呼叫每一支的destroy 因換了新的類別載入器(class loader) "},"articles/back-end/java/servlet-web/date.html":{"url":"articles/back-end/java/servlet-web/date.html","title":"Date","keywords":"","body":"DateDate Calendar 10顆星重要：getTime() "},"articles/back-end/java/servlet-web/servletinterface.html":{"url":"articles/back-end/java/servlet-web/servletinterface.html","title":"Servlet Interface","keywords":"","body":"Servlet InterfaceServletServletConfigServlet Interface Servlet destroy() init(ServletConfig config)) service(ServletRequest req, ServletResponse res) ServletConfig getInitParameter(String name) getInitParameterNames() getServletContext() getServletName() "},"articles/back-end/java/servlet-web/session.html":{"url":"articles/back-end/java/servlet-web/session.html","title":"Session機制","keywords":"","body":"Session機制什麼是Session實現使用者登入HttpSession介面之屬性(Attribute)方法程式片段(取得session擁有之所有屬性名稱、值)HttpSession介面其他方法Session機制 什麼是Session 是一種紀錄用戶端狀態的機制 儲存在伺服器上 Session相當於程式在伺服器上建立的一份客戶檔案，客戶來訪時只需查詢客戶檔案表即能追蹤 實現使用者登入 對應的類別為javax.servlet.http.HttpSession類別 每個來訪者對應一個Session物件，所有該客戶的狀態資訊都儲存在這個Session物件裡 Session物件在用戶端第一次請求伺服器時建立 Session是一種key-value屬性對，透過getAttribute(String key)及setAttribute(String key, Object value)方法讀寫客戶狀態資訊 透過request.getSession()獲得該客戶的Session，如： // 獲得Session物件 HttpSession session = request.getSession(); // 設定Session中的屬性 session.setAttribute(\"loginTime\", new Date()); // 獲得Session屬性 out.println(\"登入時間為：\" + (Date)session.getAttribute(\"loginTime\")); HttpSession介面之屬性(Attribute)方法 void session.setAttribute(String name, Object value) 將指定的物件存入session中 Object session.getAttribute(String name) 從session中取出物件 void session.removeAttribute(String name) 從session中移除物件 Enumeration session.getAttributeNames() 將目前session中的所有屬性名稱以Enumeration型態傳回 程式片段(取得session擁有之所有屬性名稱、值) Enumeration en = session.getAttributeNames(); while (en.hasMoreElements()){ String name = (String) en.nextElement(); out.println(name + \":\" + session.getAttribute(name)); } HttpSession介面其他方法 "},"articles/back-end/developing-solutions/":{"url":"articles/back-end/developing-solutions/","title":"Developing Solutions","keywords":"","body":"Developing SolutionsDeveloping Solutions 敏捷開發(Agile) "},"articles/back-end/developing-solutions/solid-she-ji-yuan-ze.html":{"url":"articles/back-end/developing-solutions/solid-she-ji-yuan-ze.html","title":"SOLID設計原則","keywords":"","body":"SOLID設計原則單一職責原則(Single responsibility principle, SRP)開放封閉原則(Open-Close principle, OCP)里氏替換原則(Liskov substitution principle, LSP)介面隔離原則(Interface segregation principle, ISP)依賴反向原則(Dependency inversion principle, DIP)SOLID設計原則 單一職責原則(Single responsibility principle, SRP) 一個模組應該只對唯一的一個角色負責。 開放封閉原則(Open-Close principle, OCP) 一個軟體製品應該對於擴展是開放的，但對於修改是封閉的。 里氏替換原則(Liskov substitution principle, LSP) 建置軟體系統必須來自於可互換的部分，這些部分必須遵守允許這些部分相互替換的契約。 介面隔離原則(Interface segregation principle, ISP) 此原則建議軟體設計者避免依賴於他們不使用的東西。 依賴反向原則(Dependency inversion principle, DIP) 實作策略的高層級程式碼不應該依賴於實作細節的低層級程式碼。相反地，細節應該依賴於策略。 "},"articles/back-end/developing-solutions/design-pattern/":{"url":"articles/back-end/developing-solutions/design-pattern/","title":"Design Pattern","keywords":"","body":"Design PatternDesign Pattern GOF的設計模式有23個： 策略模式 觀察者模式 "},"articles/back-end/developing-solutions/design-pattern/ce-lve-mo-shi.html":{"url":"articles/back-end/developing-solutions/design-pattern/ce-lve-mo-shi.html","title":"策略模式","keywords":"","body":"策略模式策略模式 優點： 缺點： "},"articles/back-end/developing-solutions/uml.html":{"url":"articles/back-end/developing-solutions/uml.html","title":"UML","keywords":"","body":"UMLUML Association Inheritance Implementation Dependency Aggregation Composition "},"articles/back-end/developing-solutions/agile/":{"url":"articles/back-end/developing-solutions/agile/","title":"Agile","keywords":"","body":"Agile漸增模式(Incremental Model)敏捷開發(Agile Development)敏捷宣言(Agile Manifesto)敏捷開發的12個原則Agile開發相關問答Agile 漸增模式(Incremental Model) 敏捷開發(Agile Development) 敏捷宣言(Agile Manifesto) 敏捷開發的12個原則 我們最優先的任務，是透過及早並持績地交付有價值的軟體來滿足客戶需求。 竭誠歡迎改變需求，甚至已處開發後期亦然。敏捷流程掌控變更，以維護客戶的競爭優勢。 經常交付可用的軟體，頻率可以從數週到數個月，以較短時間間隔為佳。 業務人員與開發者必須在專案全程中天天一起工作。 以積極的個人來建構專案，給予他們所需的環境與支援，並信任他們可以完成工作。 面對面的溝通是傳遞資訊給開發團隊及團隊成員之間效率最高且效果最佳的方法。 可用的軟體是最主要的進度量測方法。 敏捷程序提倡可持續的開發。贊助者、開發者及使用者應當能不斷地維持穩定的步調。 持續追求優越的技術與優良的設計，以強化敏捷性。 精簡─或最大化未完成工作量之技藝─是不可或缺的。 最佳的架構、需求與設計皆來自於能自我組織的團隊。 團隊定期自省如何更有效率，並據之適當地調整與修正自己的行為。 Agile開發相關問答 敏捷開發重視的是什麼？ 個人與互動 可用的軟體 與客戶合作 回應變化 附加在User Story之Acceptance Test，其： 主要目的：描述User Story的細節，設定User Story是否完成的標準 由誰負責撰寫：客戶方 什麼時候撰寫：於Coding之前撰寫 使用User Story的敏捷開發，何謂3C？ Card Conversation Confirmation 需求評估所使用之Kano模型，將需求分為哪三類？ 基本型 期望型 魅力型 估算使用者故事大小，最常用的方法？ Planning Poker 估算使用者故事大小，最常用的單位？ 故事點 理想工作天 在Release Planning時，有哪兩種不同的驅動方式？ Date-Driven Feature-Driven UML全稱 Unified Modeling Language UML統一： 統一了Notation 沒有統一Process UML主要用途： modeling write software blueprint visualization, specification, construction, documentation 使用瀑布模式有何缺點？ 使用者需求不詳盡，導致後續階段的不確定性 太慢讓使用者看到系統，可能導致系統不合使用者需求 初始階段錯誤會導致連鎖反應，使損失擴大效果 相對瀑布模式，使用漸增模式開發軟體的優點 避免錯誤放大效應 提早讓使用者見到並操作系統，使用者之意見得提早反映 較小之Increment容易管理、開發及測試 較容易應付發展過程中不斷變動之使用者需求 請解釋敏捷開發中Incremental的意義 將一個大專案切割成數個小專案，每個小專案會產生一部份可執行的軟體，整個系統依此程序漸次完成 請解釋敏捷開發中Iteration的意義 將一個大專案切割成數個小專案，每個小專案約一到四週，進行分析、設計、製作、測試工作，最後產生可執行之軟體，加到系統當中 使用者角色(User Role)有哪些屬性？ 目的 使用頻率 軟硬體專業度 領域專業度 類似軟體熟悉度 請列出Release Planning之主要工作 決定滿足條件 估算使用者故事大小 決定迭代時間長度 估算速度 排定使用者故事優先順序 選入使用者故事及交付日期 請解釋Use Case Diagram之用途 用以表現系統之邊界及系統所存在之環境(context) 用以塑模使用者之需求及系統之功能 請列舉看板方法之三個原則 visualization Limit WIP manage flow Activity Diagram的使用時機？ 描述業務流程或工作流程 描述使用者與系統之互動流程 描述操作流程 描述類別中操作之邏輯 資料庫設計之步驟： 需求的搜集與分析 概想資料庫設計 資料模型轉換 實際資料庫設計 以ER模型進行邏輯資料庫設計時，如何處理一對一及多對多的關係？ 一對一：合併兩個實體 多對多：將原關係變成實體，另建兩個一對多的關係以連接原實體 以ER模型進行邏輯資料庫設計時，如何處理實體、屬性及一對多的關係？ 實體：轉換成表格 屬性：轉換成欄位 一對多：將「一」所代表表格之PK，複製到「多」所代表表格中，並設定成FK 正規化之目的？ 資料在新增、修改或刪除時，整個系統相關資料仍能維持正確良好的狀態 正規化規則： 第一正規化：去除多值屬性 第二正規化：去除只與部分主鍵相關欄位 第三正規化：去除除主鍵外有相依關係的欄位 "},"articles/back-end/developing-solutions/agile/actionnode.html":{"url":"articles/back-end/developing-solutions/agile/actionnode.html","title":"Action Node","keywords":"","body":"Action NodeAction Node Action Node Object Node Control Node "},"articles/back-end/developing-solutions/agile/controlnode-and-flow.html":{"url":"articles/back-end/developing-solutions/agile/controlnode-and-flow.html","title":"Control Node","keywords":"","body":"Control NodeToken FlowControl Node Token Flow 物件流程：真的有物件在流動 "},"articles/back-end/developing-solutions/agile/objectnode.html":{"url":"articles/back-end/developing-solutions/agile/objectnode.html","title":"Object Node","keywords":"","body":"Object Node活動隔間(Activity Partitions)Object Node 活動隔間(Activity Partitions) 重要 "},"articles/back-end/developing-solutions/agile/usecase.html":{"url":"articles/back-end/developing-solutions/agile/usecase.html","title":"Use Case","keywords":"","body":"Use CaseUse Case ModelUse Case 符號使用案例注意事項ActorActor 符號參與者注意事項Use Case Diagram使用案例圖注意事項使用案例敘述使用案例敘述之項目事件流程主要事件流程例外事件流程使用案例情節使用案例敘述範例Use Case Use Case Model 使用案例模型包括： 業務流程描述：Activity Diagram 使用者需求與系統功能：Use Case Diagram 使用案例事件流程：Use Case Description 使用者故事及驗收測試：User Story and Acceptance Test 使用案例情節：Activity Diagram UI設計：User-Interface Prototype Use Case 符號 使用案例注意事項 使用案例之名稱通常是一個動詞片語 使用案例間之關係通常只有三種： 一般化 包含 擴充 不能有表現流程、順序等關係出現 ↑應以購物車呈現 使用案例應為EBP(Elementary Business Process)層級 Actor Actor 符號 參與者為達到某項特殊目的，在系統之內所執行的一連串行動 對系統而言，使用者可以扮演的角色；或是存在系統之外的一個實體，例如： 另一個系統或是一個資料庫 參與者是在系統之外，但又與系統有關之實體 若參與者是人類，UML是以人形符號來表現；否則為增加視覺效果，可以使用 UML擴充機制中之造型 (stereotype)機制來表現 參與者與使用案例間是以關連(Association)連接，代表資料之傳送與接收 參與者注意事項 參與者間可以有一般化(Generalization)之關係，參與者間不必有其他關係存在，因為那已是系統之外的部份 參與者應是使用者可以扮演的角色，而非特定之人 參與者是角色，而非職務 Use Case Diagram 使用案例圖注意事項 使用案例圖沒有階層性 使用案例圖中可用套件符號來表示使用案例間之相關性 使用案例敘述 在撰寫程式前，先確定使用案例之細節(程序及邏輯) 描述系統作什麼(what)而非定義如何作(how) 使用案例敘述通常包括下列項目： 使用案例名稱 (Use Case Name) 功能簡述 (Brief Description) 先決條件 (Precondition) 後續狀況 (Post condition) 特殊需求 (Special Requirements) 擴充點 (Extension Points) 事件流程 (Flow of Events) 使用案例敘述之項目 需求: 功能性：use case diagram 非功能性：品質(測試) 使用案例名稱 (Use Case Name) 使用案例名稱必須和使用案例圖中之名稱相同 功能簡述 (Brief Description) 說明本使用案例之功能 先決條件 (Precondition) 在進行此使用案例前，系統必需滿足之條件 後續狀況 (Post condition) 當使用案例結束時，系統必需滿足之狀 特殊需求 (Special Requirements) performance, reliability(信賴度or可靠度), availability, accuracy, security等非功能性需求 Mean Time Between Failures(MTBF,平均故障間隔)=2000hrs 數字越大表示越不容易出錯 擴充點 (Extension Points) 列舉本使用案例所有的擴充點 事件流程 (Flow of Events) 以上前6項是表頭 事件流程 是參與者與系統間之一連串互動過程 使用案例中有兩種事件流程： 主要事件流程 (main flow of events)，或稱基本事件途徑(basic course of events)，簡稱主要流程 例外事件流程 (exceptional flow of events)，或稱替代行動途徑(alternate course of events)，簡稱例外流程 錯誤流程、較不常經過(ex:忘記密碼) 主要事件流程是描述在正常狀況下，參與者和使用案例會遵循的一個由開始到結 束之完整主要路徑。基本假設是參與者不會出錯，且系統也不會產生錯誤 例外事件流程是使用案例中代表錯誤狀況的路徑，或是參與者及系統較不常經過 的路徑 主要事件流程 Customer在【首頁】上點選了【登錄】按鈕 (E-1)(E-2) 主動語態簡單句 系統顯示【Login】頁面 Customer輸入其使用者代號及通行密碼後，點選【OK】按鈕 系統根據永久保存的Account資料來驗證登錄資訊，然後讓Customer回到【首頁】 (E-3)(E-4)(E-5) 例外事件流程 E-1 選擇加入會員 若Customer點選【新的帳號】按鈕，系統顯示【產生新的帳號】頁面 E-2 查看提示訊息 若Customer點選【忘記密碼】按紐，系統顯示一個對話盒，其中包含為此Customer所儲存的提示訊息。 當Customer點選【確認】按鈕，系統讓Customer回到【首頁】 E-3 使用者代號錯誤 若Customer輸入了一個系統無法辨識的使用者代號，則系統將顯示【產生新的帳號】頁面 E-4 通行密碼錯誤 若Customer輸入了一個錯誤的通行密碼，則系統提示Customer重新輸入其通行密碼 E-5 通行密碼三次錯誤 若Customer連續三次輸入錯誤的通行密碼，系統顯示一個頁面通知Customer應該與系統服務部門連繫 使用案例情節 使用案例敘述範例 此範例對敏捷方法來說，過於繁複，解法是User Story(ch15) 使用者不關心：用什麼技術、相關技術細節 使用者關心：有哪些功能、可否滿足業務需求、好不好操作、介面畫面票不漂亮，簡言之如下三點： 是否有使用者需求的功能 操作步驟符不符合業務需求 是否user friendly "},"articles/back-end/developing-solutions/agile/userstory.html":{"url":"articles/back-end/developing-solutions/agile/userstory.html","title":"User Story","keywords":"","body":"User Storyuse case 三種關係一般化(Generalization):繼承包含(Include)擴充(Extend)User Story 驗收測試是在coding之前撰寫 Product Backlog: 待辦清單 Product -> Release(version) -> use case(Feature) -> user story use case 三種關係 一般化(Generalization):繼承 包含(Include) 把共同部分做抽離 很常用，所以非常重要 『包含正常、擴充相反』 擴充(Extend) "},"articles/back-end/developing-solutions/agile/user-story-2.html":{"url":"articles/back-end/developing-solutions/agile/user-story-2.html","title":"User Story (2)","keywords":"","body":"User Story (2)估算故事之單位及方法估算單位估算方法：絕對 vs. 相對估算方法：少數 vs. 多數以故事點估算之結果紀錄Planning Poker什麼是Planning Poker(規劃撲克牌)為何要使用Planning Poker估算準備估算之程序使用Planning Poker的好處User Story (2) 估算故事之單位及方法 估算單位 實際工作天 理想工作天 內外若無共識，容易造成誤會 故事點 比較相對大小 衣服大小：S, M, L 易上手，較不精準，且無法運算 估算方法：絕對 vs. 相對 絕對計算 實際工作天、理想工作天 易受主觀意識影響 相對比較 故事點、衣服大小 比絕對容易評估 易達成共識 舉例：兩棟建築物高度比較 估算方法：少數 vs. 多數 少數專家，單獨估算 召集容易，單獨估算 易有偏見或盲點 多人合作，達成共識 截長補短 預估更客觀 以故事點估算之結果紀錄 費氏數列 注意事項 0：\"這故事已完成\" or \"這故事沒啥，幾分鐘內搞定' ?：\"我一點概念都沒有，沒有主意\" 咖啡杯：\"我已經太累了，先休息一下吧\" Planning Poker 什麼是Planning Poker(規劃撲克牌) 又稱為Scrum poker，是一種以共識(consensus-based)為主的估算技術，用以估算user stories的相對大小 為何要使用Planning Poker 可以避免相互干擾 強迫參與者獨立思考 估算準備 多副Scrum poker及會議室 Egg timer Scrum Poker apps 估算之程序 由一個人負責主持會議， 但是不一起玩， 通常由產品負責人(Product Owner) 擔任。 由最熟悉的開發人員來解釋這個待評估項目，團隊成員可以趁機釐清一些事情，最後會由住持人做出總結。 每個人這時候便開始對這個項目做評估， 也就是想要拿出哪個數字出來，來代表評估的值。 想好之後，每個人同時顯示他們所評估的值。 顯示之後，主持人會請最高和最低值的人, 解釋為什麼會是這個答案，困難點或是容易點在哪裡。 重複步驟3-5 ，直到大家達到共識為止，或是大部分的人有相同的答案。 使用Planning Poker的好處 由做事的人共同決定出一個合理客觀的預估結果，有參與感且無怨言。 決定的結果是產品負責人與開發團隊的共識，減少未來針鋒相對、各說各話的情況發生。 每個人都可以瞭解需求，未來每個人都可以擔任實作這個需求的人選，當需要支援時，也隨時可以有人一同開發或備援。 在還沒動手作之前，就可以把需求不明確的部分，有疑慮的部分釐清。 在還沒動手作之前，就可以在團隊中找到大家認同最好最有效率的實作方式。 除非整個開發團隊都是灌水的人，否則這個數字就反映了團隊共同認知的事實，產品負責人可從中了解需求與評估實作中間的落差。 透過比較需求之間複雜度的相對大小，未來產品負責人對評估迭代可能可以承諾完成多少需求，也會有個比較的基底。 "},"articles/back-end/developing-solutions/agile/diagram.html":{"url":"articles/back-end/developing-solutions/agile/diagram.html","title":"Diagram","keywords":"","body":"Diagram使用時機描述業務流程或工作流程圖描述使用者與系統之互動流程描述操作流程專案業務流程圖Diagram 使用時機 描述業務流程或工作流程圖 描述使用者與系統之互動流程 描述操作流程 專案業務流程圖 老師舉例 "},"articles/front-end/html/":{"url":"articles/front-end/html/","title":"HTML","keywords":"","body":"HTML網頁欄位架構、表格、form表單等的快速建立方式範例(Emmet套件功能)HTML新標籤頁面架構標籤figure, figcaption影音標籤HTML 網頁欄位架構、表格、form表單等的快速建立方式範例(Emmet套件功能) table>(tr>td*3)*2 form>fieldset>legend{contact US}+(p>label+input)*6 header>h1+small^nav>a*4^video+#left>(h2+p*3)*4^#right>img*3+form^footer div>h1{NEWS}^div+div HTML新標籤 頁面架構標籤 網頁範例 HTML5-頁面整合 請參考pageMix2.jpg 完成 h1+small^nav>a*4^video+#left>(h2+p*3)*4^#right>img*3+form^footer --> 親近自然 擁抱美麗 讓我們迎向大自然 充滿笑聲迴盪在每一天 露營禮節 器材準備 地點推薦 聯絡我們 露營禮節 營帳規格 野炊安全 入山活動 器材準備 細節規劃 任務分配 環境安全 地點推薦 北部地區 中部地區 南部地區 連絡我們 來訪地圖 留言討論 即時通訊 contact US 您的姓名： 電子郵件： 聯絡電話： 出生日期： 居住地區： 露營經驗:陌生 | 新手 | 老經驗 Happy Camp &copy;Copyright 2020 by Your LOGO - XXXX@gmail.com figure, figcaption figure:獨立內容區段描述 figcaption:獨立內容區段描述標題說明 稻田 影音標籤 "},"articles/front-end/html/form.html":{"url":"articles/front-end/html/form.html","title":"form","keywords":"","body":"form說明form contact US Name: Email: Phone: Web: Birthday: Order: Product: Satisfied:OK | GOOD | PERFECT 說明 本範例表單輸入此行快速產生架構：form>fieldset>legend{contact US}+(p>label+input)*6 元素說明： 元素 說明 fieldset 用來對form表單中的控制元件做分組 legend 作為表單的標題，位於fieldset下的第一個 datalist 下拉表單，與list屬性配合 屬性說明： 屬性 說明 required \b使欄位不得為空白 placeholder 讓欄位空白時顯示文字 value 設定初始值 min 設定最小值 max 設定最大值 step 設定每次增減值的單位數 list 下拉表單，與datalist標籤配合 type input元素的類型，詳下表格 類型(type)說明： 類型 說明 text 字元 email Email tel 號碼 url 網址 number 數量 date 日期（會有小月曆） range 可拉的範圍桿 "},"articles/front-end/css.html":{"url":"articles/front-end/css.html","title":"CSS","keywords":"","body":"CSSCSS body{ background-color: #000000;/*black, #000000,#000*/ text-align: center; color: yellow; } 連結外部CSS檔： "}}